# -*- coding: utf-8 -*-
"""
Vape Shop Bot — full single-file version with:
- Catalog (pods, cartridges, liquids) + add to cart
- Cart review / clear / checkout
- Orders with payment methods (COD, card, crypto)
- User payment confirmation -> admin confirmation
- Admin panel: orders, reviews moderation, referrals stats, broadcast
- Reviews: submit -> moderation -> publish, show last N
- Referral system with /start <ref_id>, spending accumulation, reward threshold
- Persistent storage in ./data/*.json (JSON files), loaded on start and saved on changes
- Basic anti-UX issues: invalidate old inline keyboards via "view tokens"
- RU/UA localization

Library: pyTelegramBotAPI (telebot)
Python: 3.9+
Author: Generated by ChatGPT (GPT-5 Thinking)
"""

import os
import json
import time
import logging
from typing import Dict, List, Any, Optional, Tuple
import telebot
from telebot import types

# ===============================
# --------- CONFIG --------------
# ===============================

TOKEN = os.getenv("8400828602:AAGmF8japcI3YkWRmvd2o9QXoohcYc4I7vQ", "8400828602:AAGmF8japcI3YkWRmvd2o9QXoohcYc4I7vQ")  # <- replace or set env var
ADMIN_CHAT_ID = int(os.getenv("ADMIN_CHAT_ID", "5539798707"))     # <- replace with your Telegram user id

# Payment/Refl thresholds
REF_REWARD_THRESHOLD = 4100

DATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "data")
os.makedirs(DATA_DIR, exist_ok=True)

# Files
F_USERS     = os.path.join(DATA_DIR, "users.json")      # {user_id: {"lang": "ru"/"ua", "role": "user"/"admin"}}
F_CARTS     = os.path.join(DATA_DIR, "carts.json")      # {user_id: [product_key, ...]}
F_ORDERS    = os.path.join(DATA_DIR, "orders.json")     # {order_id: {...}}
F_REVIEWS   = os.path.join(DATA_DIR, "reviews.json")    # [{"user_id":..,"text":..,"approved":bool,"created":ts}, ...]
F_REFERRALS = os.path.join(DATA_DIR, "referrals.json")  # {"map": {referrer_id: [child_ids]}, "spending": {referrer_id: sum}}
F_COUNTERS  = os.path.join(DATA_DIR, "counters.json")   # {"order_counter": int}
F_VIEWS     = os.path.join(DATA_DIR, "views.json")      # {"active_view": {user_id: int}}

# ===============================
# --------- LOGGING -------------
# ===============================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s"
)
log = logging.getLogger("bot")

# ===============================
# --------- STORAGE -------------
# ===============================

def _load(path: str, default):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return default

def _save(path: str, data):
    tmp = path + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    os.replace(tmp, path)

USERS: Dict[str, Dict[str, Any]] = _load(F_USERS, {})
CARTS: Dict[str, List[str]] = _load(F_CARTS, {})
ORDERS: Dict[str, Dict[str, Any]] = _load(F_ORDERS, {})
REVIEWS: List[Dict[str, Any]] = _load(F_REVIEWS, [])
REF = _load(F_REFERRALS, {"map": {}, "spending": {}})   # "map": {referrer: [childs]}, "spending": {referrer: sum}
COUNTERS = _load(F_COUNTERS, {"order_counter": 1})
VIEWS = _load(F_VIEWS, {"active_view": {}})             # per-user active inline keyboard version

def save_all():
    _save(F_USERS, USERS)
    _save(F_CARTS, CARTS)
    _save(F_ORDERS, ORDERS)
    _save(F_REVIEWS, REVIEWS)
    _save(F_REFERRALS, REF)
    _save(F_COUNTERS, COUNTERS)
    _save(F_VIEWS, VIEWS)

def ensure_user(uid: int):
    uid = str(uid)
    if uid not in USERS:
        USERS[uid] = {"lang": "ru", "role": "admin" if int(uid)==ADMIN_CHAT_ID else "user"}
        _save(F_USERS, USERS)

def get_lang(uid: int) -> str:
    ensure_user(uid)
    return USERS[str(uid)].get("lang", "ru")

def set_lang(uid: int, lang: str):
    ensure_user(uid)
    USERS[str(uid)]["lang"] = lang
    _save(F_USERS, USERS)

def get_role(uid: int) -> str:
    ensure_user(uid)
    return USERS[str(uid)].get("role", "user")

def set_role(uid: int, role: str):
    ensure_user(uid)
    USERS[str(uid)]["role"] = role
    _save(F_USERS, USERS)

def get_cart(uid: int) -> List[str]:
    cart = CARTS.setdefault(str(uid), [])
    _save(F_CARTS, CARTS)
    return cart

def clear_cart(uid: int):
    CARTS[str(uid)] = []
    _save(F_CARTS, CARTS)

def add_to_cart(uid: int, product_key: str):
    cart = get_cart(uid)
    cart.append(product_key)
    _save(F_CARTS, CARTS)

def new_order_id() -> int:
    oid = COUNTERS.get("order_counter", 1)
    COUNTERS["order_counter"] = oid + 1
    _save(F_COUNTERS, COUNTERS)
    return oid

def add_review(user_id: int, text: str):
    REVIEWS.append({"user_id": user_id, "text": text, "approved": False, "created": int(time.time())})
    _save(F_REVIEWS, REVIEWS)

def approve_review(idx: int) -> bool:
    if 0 <= idx < len(REVIEWS):
        REVIEWS[idx]["approved"] = True
        _save(F_REVIEWS, REVIEWS)
        return True
    return False

def delete_review(idx: int) -> bool:
    if 0 <= idx < len(REVIEWS):
        REVIEWS.pop(idx)
        _save(F_REVIEWS, REVIEWS)
        return True
    return False

def add_referral(parent_id: int, child_id: int):
    m = REF["map"].setdefault(str(parent_id), [])
    if str(child_id) not in m and parent_id != child_id:
        m.append(str(child_id))
        _save(F_REFERRALS, REF)

def add_spending(parent_id: int, amount: int):
    cur = int(REF["spending"].get(str(parent_id), 0))
    REF["spending"][str(parent_id)] = cur + int(amount)
    _save(F_REFERRALS, REF)

def get_view_token(uid: int) -> int:
    v = VIEWS["active_view"].get(str(uid), 0) + 1
    VIEWS["active_view"][str(uid)] = v
    _save(F_VIEWS, VIEWS)
    return v

def check_view_token(uid: int, token: int) -> bool:
    return VIEWS["active_view"].get(str(uid), 0) == token

# ===============================
# --------- CATALOG -------------
# ===============================

cartridge_voopoo_price = 145
cartridge_vaporesso_price = 135

PRODUCTS = {
    # Voopoo
    "voopoo_argus_3ml_07": {"name_ru": "Voopoo Argus 3ml 0.7", "name_ua": "Voopoo Argus 3ml 0.7", "price": cartridge_voopoo_price, "category": "voopoo"},
    "voopoo_argus_3ml_10": {"name_ru": "Voopoo Argus 3ml 1.0", "name_ua": "Voopoo Argus 3ml 1.0", "price": cartridge_voopoo_price, "category": "voopoo"},
    "voopoo_argus_3ml_04": {"name_ru": "Voopoo Argus 3ml 0.4", "name_ua": "Voopoo Argus 3ml 0.4", "price": cartridge_voopoo_price, "category": "voopoo"},
    "voopoo_vmate_3ml_07": {"name_ru": "Voopoo Vmate 3ml 0.7", "name_ua": "Voopoo Vmate 3ml 0.7", "price": cartridge_voopoo_price, "category": "voopoo"},
    "voopoo_vmate_2ml_07_tpd": {"name_ru": "Voopoo Vmate 2ml 0.7 (TPD)", "name_ua": "Voopoo Vmate 2ml 0.7 (TPD)", "price": cartridge_voopoo_price, "category": "voopoo"},
    "voopoo_vmate_3ml_04": {"name_ru": "Voopoo Vmate 3ml 0.4", "name_ua": "Voopoo Vmate 3ml 0.4", "price": cartridge_voopoo_price, "category": "voopoo"},
    "voopoo_vmate_2ml_04_tpd": {"name_ru": "Voopoo Vmate 2ml 0.4 (TPD)", "name_ua": "Voopoo Vmate 2ml 0.4 (TPD)", "price": cartridge_voopoo_price, "category": "voopoo"},

    # Elf Bar ELFX
    "elfx_2ml_06": {"name_ru": "Elfx 2ml 0.6", "name_ua": "Elfx 2ml 0.6", "price": 135, "category": "elfx"},
    "elfx_2ml_08": {"name_ru": "Elfx 2ml 0.8", "name_ua": "Elfx 2ml 0.8", "price": 135, "category": "elfx"},

    # Vaporesso
    "vaporesso_xros_1_0_3ml": {"name_ru": "Vaporesso Xros Series 1.0, 3 ml", "name_ua": "Vaporesso Xros Series 1.0, 3 ml", "price": cartridge_vaporesso_price, "category": "vaporesso"},
    "vaporesso_xros_1_0_2ml": {"name_ru": "Vaporesso Xros Series 1.0, 2 ml", "name_ua": "Vaporesso Xros Series 1.0, 2 ml", "price": cartridge_vaporesso_price, "category": "vaporesso"},
    "vaporesso_xros_0_8_3ml": {"name_ru": "Vaporesso Xros Series 0.8, 3 ml", "name_ua": "Vaporesso Xros Series 0.8, 3 ml", "price": cartridge_vaporesso_price, "category": "vaporesso"},
    "vaporesso_xros_0_8_2ml": {"name_ru": "Vaporesso Xros Series 0.8, 2 ml", "name_ua": "Vaporesso Xros Series 0.8, 2 ml", "price": cartridge_vaporesso_price, "category": "vaporesso"},
    "vaporesso_xros_0_6_3ml": {"name_ru": "Vaporesso Xros Series 0.6, 3 ml", "name_ua": "Vaporesso Xros Series 0.6, 3 ml", "price": cartridge_vaporesso_price, "category": "vaporesso"},
    "vaporesso_xros_0_6_2ml": {"name_ru": "Vaporesso Xros Series 0.6, 2 ml", "name_ua": "Vaporesso Xros Series 0.6, 2 ml", "price": cartridge_vaporesso_price, "category": "vaporesso"},
    "vaporesso_xros_0_4_3ml": {"name_ru": "Vaporesso Xros Series 0.4, 3 ml", "name_ua": "Vaporesso Xros Series 0.4, 3 ml", "price": cartridge_vaporesso_price, "category": "vaporesso"},
    "vaporesso_xros_0_4_2ml": {"name_ru": "Vaporesso Xros Series 0.4, 2 ml", "name_ua": "Vaporesso Xros Series 0.4, 2 ml", "price": cartridge_vaporesso_price, "category": "vaporesso"},
}

PODS = {
    "vaporesso_xros_5_mini": {"name_ru": "Vaporesso xros 5 mini", "name_ua": "Vaporesso xros 5 mini", "price": 850},
    "vaporesso_xros_4_mini": {"name_ru": "Vaporesso xros 4 mini", "name_ua": "Vaporesso xros 4 mini", "price": 809},
    "vaporesso_xros_5": {"name_ru": "Vaporesso xros 5", "name_ua": "Vaporesso xros 5", "price": 1129},
    "elfx_pro": {"name_ru": "Elbar Bar ELFX Pro", "name_ua": "Elbar Bar ELFX Pro", "price": 849},
    "elf_bar_ev15000": {"name_ru": "Elf Bar EV15000", "name_ua": "Elf Bar EV15000", "price": 299},
    "voopoo_argus_g2": {"name_ru": "Voopoo Argus G2", "name_ua": "Voopoo Argus G2", "price": 1049},
    "voopoo_vmate_i2": {"name_ru": "Voopoo Vmate I2 (второе поколение)", "name_ua": "Voopoo Vmate I2 (друге покоління)", "price": 719},
}

LIQUIDS = {
    "chaser_30_watermelon": {"name_ru": "Chaser (Арбуз)", "name_ua": "Chaser (Кавун)", "price": 285, "category": "chaser_30"},
    "chaser_30_peach": {"name_ru": "Chaser (Персик)", "name_ua": "Chaser (Персик)", "price": 285, "category": "chaser_30"},
    "chaser_30_berries": {"name_ru": "Chaser (Ягоды)", "name_ua": "Chaser (Ягоди)", "price": 285, "category": "chaser_30"},
    "chaser_30_banana": {"name_ru": "Chaser (Банан)", "name_ua": "Chaser (Банан)", "price": 285, "category": "chaser_30"},
    "chaser_30_blue_raspberry": {"name_ru": "Chaser (Голубая малина)", "name_ua": "Chaser (Блакитна малина)", "price": 285, "category": "chaser_30"},
    "chaser_30_grape": {"name_ru": "Chaser (Виноград)", "name_ua": "Chaser (Виноград)", "price": 285, "category": "chaser_30"},
    "chaser_30_cherry": {"name_ru": "Chaser (Вишня)", "name_ua": "Chaser (Вишня)", "price": 285, "category": "chaser_30"},
    "chaser_30_cherry_menthol": {"name_ru": "Chaser (Вишня ментол)", "name_ua": "Chaser (Вишня ментол)", "price": 285, "category": "chaser_30"},
    "chaser_30_pomegranate": {"name_ru": "Chaser (Гранат)", "name_ua": "Chaser (Гранат)", "price": 285, "category": "chaser_30"},
    "chaser_30_melon": {"name_ru": "Chaser (Дыня)", "name_ua": "Chaser (Диня)", "price": 285, "category": "chaser_30"},
    "chaser_30_yellow_raspberry": {"name_ru": "Chaser (Желтая малина)", "name_ua": "Chaser (Жовта малина)", "price": 285, "category": "chaser_30"},
    "chaser_30_yellow_cherry": {"name_ru": "Chaser (Желтая черешня)", "name_ua": "Chaser (Жовта черешня)", "price": 285, "category": "chaser_30"},
    "chaser_30_yellow_dragonfruit": {"name_ru": "Chaser (Жёлтый драгонфрукт)", "name_ua": "Chaser (Жовтий драгонфрукт)", "price": 285, "category": "chaser_30"},
    "chaser_30_kiwi": {"name_ru": "Chaser (Киви)", "name_ua": "Chaser (Ківі)", "price": 285, "category": "chaser_30"},

    "chaser_10_banana": {"name_ru": "Chaser (Банан)", "name_ua": "Chaser (Банан)", "price": 152, "category": "chaser_10"},
    "chaser_10_blue_raspberry": {"name_ru": "Chaser (Голубая малина)", "name_ua": "Chaser (Блакитна малина)", "price": 152, "category": "chaser_10"},
    "chaser_10_grape": {"name_ru": "Chaser (Виноград)", "name_ua": "Chaser (Виноград)", "price": 152, "category": "chaser_10"},
    "chaser_10_cherry": {"name_ru": "Chaser (Вишня)", "name_ua": "Chaser (Вишня)", "price": 152, "category": "chaser_10"},
    "chaser_10_cherry_menthol": {"name_ru": "Chaser (Вишня ментол)", "name_ua": "Chaser (Вишня ментол)", "price": 152, "category": "chaser_10"},
    "chaser_10_pomegranate": {"name_ru": "Chaser (Гранат)", "name_ua": "Chaser (Гранат)", "price": 152, "category": "chaser_10"},
    "chaser_10_melon": {"name_ru": "Chaser (Дыня)", "name_ua": "Chaser (Дыня)", "price": 152, "category": "chaser_10"},
    "chaser_10_watermelon": {"name_ru": "Chaser (Арбуз)", "name_ua": "Chaser (Кавун)", "price": 152, "category": "chaser_10"},
    "chaser_10_watermelon_menthol": {"name_ru": "Chaser (Арбуз ментол)", "name_ua": "Chaser (Кавун ментол)", "price": 152, "category": "chaser_10"},
    "chaser_10_kiwi": {"name_ru": "Chaser (Киви)", "name_ua": "Chaser (Ківі)", "price": 152, "category": "chaser_10"},
    "chaser_10_lemon": {"name_ru": "Chaser (Лимон)", "name_ua": "Chaser (Лимон)", "price": 152, "category": "chaser_10"},
    "chaser_10_mint": {"name_ru": "Chaser (Мята)", "name_ua": "Chaser (Мʼята)", "price": 152, "category": "chaser_10"},
    "chaser_10_peach": {"name_ru": "Chaser (Персик)", "name_ua": "Chaser (Персик)", "price": 152, "category": "chaser_10"},
    "chaser_10_strawberry": {"name_ru": "Chaser (Клубника)", "name_ua": "Chaser (Полуниця)", "price": 152, "category": "chaser_10"},
    "chaser_10_blackcurrant_menthol": {"name_ru": "Chaser (Смородина ментол)", "name_ua": "Chaser (Смородина ментол)", "price": 152, "category": "chaser_10"},
    "chaser_10_blueberry_menthol": {"name_ru": "Chaser (Черника ментол)", "name_ua": "Chaser (Чорниця ментол)", "price": 152, "category": "chaser_10"},
    "chaser_10_berries": {"name_ru": "Chaser (Ягоды)", "name_ua": "Chaser (Ягоди)", "price": 152, "category": "chaser_10"},

    "elfliq_10_apple_peach": {"name_ru": "Elfliq (Яблоко-Персик)", "name_ua": "Elfliq (Яблуко-Персик)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_lemonade": {"name_ru": "Elfliq (Лимонад)", "name_ua": "Elfliq (Лимонад)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_blueberry": {"name_ru": "Elfliq (Черника)", "name_ua": "Elfliq (Чорниця)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_blueberry_raspberry": {"name_ru": "Elfliq (Черника-Кислая-Малина)", "name_ua": "Elfliq (Чорниця-Кисла-Малина)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_cherry": {"name_ru": "Elfliq (Вишня)", "name_ua": "Elfliq (Вишня)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_cherry_cola": {"name_ru": "Elfliq (Вишневая Кола)", "name_ua": "Elfliq (Вишнева Кола)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_cola": {"name_ru": "Elfliq (Кола)", "name_ua": "Elfliq (Кола)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_pb_cloud": {"name_ru": "Elfliq (P&B Cloud - Зефир)", "name_ua": "Elfliq (P&B Cloud - Зефір)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_energy": {"name_ru": "Elfliq (Энергетик)", "name_ua": "Elfliq (Енергетик)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_grape": {"name_ru": "Elfliq (Виноград)", "name_ua": "Elfliq (Виноград)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_kiwi_passion_guava": {"name_ru": "Elfliq (Киви-Маракуйя-Гуава)", "name_ua": "Elfliq (Ківі-Маракуйя-Гуава)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_peach_ice": {"name_ru": "Elfliq (Персиковый лёд)", "name_ua": "Elfliq (Персиковий лід)", "price": 153, "category": "elfliq_10"},
    "elfliq_10_pink_grapefruit": {"name_ru": "Elfliq (Розовый грейпфрут)", "name_ua": "Elfliq (Рожевий грейпфрут)", "price": 153, "category": "elfliq_10"},

    "elfliq_30_blue_pink_lemonade": {"name_ru": "Elfliq (Сине-розовый лимонад)", "name_ua": "Elfliq (Синьо-рожевий лимонад)", "price": 299, "category": "elfliq_30"},
    "elfliq_30_blueberry_raspberry": {"name_ru": "Elfliq (Черника кислая малина)", "name_ua": "Elfliq (Чорниця кисла малина)", "price": 299, "category": "elfliq_30"},
    "elfliq_30_watermelon": {"name_ru": "Elfliq (Арбуз)", "name_ua": "Elfliq (Кавун)", "price": 299, "category": "elfliq_30"},
    "elfliq_30_kiwi_passion_guava": {"name_ru": "Elfliq (Киви маракуйя гуава)", "name_ua": "Elfliq (Ківі маракуйя гуава)", "price": 299, "category": "elfliq_30"},
    "elfliq_30_cream_tobacco": {"name_ru": "Elfliq (Сливки табак)", "name_ua": "Elfliq (Сливки тютюн)", "price": 299, "category": "elfliq_30"},
    "elfliq_30_cola": {"name_ru": "Elfliq (Кола)", "name_ua": "Elfliq (Кола)", "price": 299, "category": "elfliq_30"},
    "elfliq_30_apple_peach": {"name_ru": "Elfliq (Яблоко персик)", "name_ua": "Elfliq (Яблуко персик)", "price": 299, "category": "elfliq_30"},
    "elfliq_30_raspberry": {"name_ru": "Elfliq (Малина)", "name_ua": "Elfliq (Малина)", "price": 299, "category": "elfliq_30"},
    "elfliq_30_mint": {"name_ru": "Elfliq (Мята)", "name_ua": "Elfliq (Мʼята)", "price": 299, "category": "elfliq_30"},
    "elfliq_30_peach": {"name_ru": "Elfliq (Персик)", "name_ua": "Elfliq (Персик)", "price": 299, "category": "elfliq_30"},

    "elix_10_watermelon_mint": {"name_ru": "Elix (Арбуз-Мята)", "name_ua": "Elix (Кавун-Мʼята)", "price": 146, "category": "elix_10"},
    "elix_10_banana": {"name_ru": "Elix (Банан)", "name_ua": "Elix (Банан)", "price": 146, "category": "elix_10"},
    "elix_10_grape": {"name_ru": "Elix (Виноград)", "name_ua": "Elix (Виноград)", "price": 146, "category": "elix_10"},
    "elix_10_blue_raspberry_mint": {"name_ru": "Elix (Голубая малина мята)", "name_ua": "Elix (Блакитна малина мʼята)", "price": 146, "category": "elix_10"},
    "elix_10_grapefruit": {"name_ru": "Elix (Грейпфрут)", "name_ua": "Elix (Грейпфрут)", "price": 146, "category": "elix_10"},
    "elix_10_pear": {"name_ru": "Elix (Груша)", "name_ua": "Elix (Груша)", "price": 146, "category": "elix_10"},
    "elix_10_melon": {"name_ru": "Elix (Дыня)", "name_ua": "Elix (Дыня)", "price": 146, "category": "elix_10"},
    "elix_10_green_apple": {"name_ru": "Elix (Зеленое яблоко)", "name_ua": "Elix (Зелене яблуко)", "price": 146, "category": "elix_10"},
    "elix_10_wild_strawberry": {"name_ru": "Elix (Земляника)", "name_ua": "Elix (Суниця)", "price": 146, "category": "elix_10"},
    "elix_10_red_raspberry": {"name_ru": "Elix (Красная малина)", "name_ua": "Elix (Червона малина)", "price": 146, "category": "elix_10"},
    "elix_10_forest_berries": {"name_ru": "Elix (Лесные ягоды)", "name_ua": "Elix (Лісові ягоди)", "price": 146, "category": "elix_10"},
    "elix_10_lychee": {"name_ru": "Elix (Личи)", "name_ua": "Elix (Лічі)", "price": 146, "category": "elix_10"},
    "elix_10_mint": {"name_ru": "Elix (Мята)", "name_ua": "Elix (Мʼята)", "price": 146, "category": "elix_10"},
    "elix_10_nectarine": {"name_ru": "Elix (Нектарин)", "name_ua": "Elix (Нектарин)", "price": 146, "category": "elix_10"},
    "elix_10_blackcurrant_mint": {"name_ru": "Elix (Смородина мята)", "name_ua": "Elix (Смородина мʼята)", "price": 146, "category": "elix_10"},
    "elix_10_cherry": {"name_ru": "Elix (Черешня)", "name_ua": "Elix (Черешня)", "price": 146, "category": "elix_10"},

    "elix_30_blue_raspberry_mint": {"name_ru": "Elix (Голубая малина мята)", "name_ua": "Elix (Блакитна малина мʼята)", "price": 277, "category": "elix_30"},
    "elix_30_wild_strawberry": {"name_ru": "Elix (Земляника)", "name_ua": "Elix (Суниця)", "price": 277, "category": "elix_30"},
    "elix_30_blackcurrant_mint": {"name_ru": "Elix (Смородина мята)", "name_ua": "Elix (Смородина мʼята)", "price": 277, "category": "elix_30"},
    "elix_30_green_apple": {"name_ru": "Elix (Зеленое яблоко)", "name_ua": "Elix (Зелене яблуко)", "price": 277, "category": "elix_30"},
    "elix_30_lychee": {"name_ru": "Elix (Личи)", "name_ua": "Elix (Лічі)", "price": 277, "category": "elix_30"},
    "elix_30_watermelon_mint": {"name_ru": "Elix (Арбуз мята)", "name_ua": "Elix (Кавун мʼята)", "price": 277, "category": "elix_30"},
    "elix_30_red_raspberry": {"name_ru": "Elix (Красная малина)", "name_ua": "Elix (Червона малина)", "price": 277, "category": "elix_30"},
    "elix_30_melon": {"name_ru": "Elix (Дыня)", "name_ua": "Elix (Дыня)", "price": 277, "category": "elix_30"},
    "elix_30_cherry": {"name_ru": "Elix (Черешня)", "name_ua": "Elix (Черешня)", "price": 277, "category": "elix_30"},
    "elix_30_banana": {"name_ru": "Elix (Банан)", "name_ua": "Elix (Банан)", "price": 277, "category": "elix_30"},
    "elix_30_grapefruit": {"name_ru": "Elix (Грейпфрут)", "name_ua": "Elix (Грейпфрут)", "price": 277, "category": "elix_30"},
    "elix_30_grape": {"name_ru": "Elix (Виноград)", "name_ua": "Elix (Виноград)", "price": 277, "category": "elix_30"},
    "elix_30_pear": {"name_ru": "Elix (Груша)", "name_ua": "Elix (Груша)", "price": 277, "category": "elix_30"},
    "elix_30_forest_berries": {"name_ru": "Elix (Лесные ягоды)", "name_ua": "Elix (Лісові ягоди)", "price": 277, "category": "elix_30"},
    "elix_30_nectarine": {"name_ru": "Elix (Нектарин)", "name_ua": "Elix (Нектарин)", "price": 277, "category": "elix_30"},
    "elix_30_mint": {"name_ru": "Elix (Мята)", "name_ua": "Elix (Мʼята)", "price": 277, "category": "elix_30"},
}

# ===============================
# --------- I18N ----------------
# ===============================

def t(key: str, lang: str) -> str:
    texts = {
        "language_select": {"ru": "Выберите язык / Оберіть мову:", "ua": "Оберіть мову / Виберіть язык:"},
        "main_menu": {"ru": "Главное меню", "ua": "Головне меню"},
        "catalog": {"ru": "Каталог", "ua": "Каталог"},
        "cartridges": {"ru": "Картриджи", "ua": "Картриджі"},
        "pods": {"ru": "Под системы", "ua": "Под системи"},
        "liquids": {"ru": "Жидкости", "ua": "Рідини"},
        "back": {"ru": "Назад", "ua": "Назад"},
        "cart": {"ru": "Корзина", "ua": "Кошик"},
        "cart_empty": {"ru": "Корзина пуста", "ua": "Кошик порожній"},
        "cart_cleared": {"ru": "Корзина очищена", "ua": "Кошик очищено"},
        "add_cart_success": {"ru": "Товар {name} добавлен в корзину", "ua": "Товар {name} додано в кошик"},
        "checkout": {"ru": "Оформить заказ", "ua": "Оформити замовлення"},
        "orders": {"ru": "Мои заказы", "ua": "Мої замовлення"},
        "orders_empty": {"ru": "У вас пока нет заказов.", "ua": "У вас поки немає замовлень."},
        "order_created": {"ru": "Заказ #{order_id} создан!", "ua": "Замовлення #{order_id} створено!"},
        "pay_cod": {"ru": "Оплата при получении", "ua": "Оплата при отриманні"},
        "pay_card": {"ru": "Оплата картой", "ua": "Оплата карткою"},
        "pay_crypto": {"ru": "Оплата криптовалютой", "ua": "Оплата криптовалютою"},
        "pay_prepay_info": {
            "ru": "Оплата картой. Внимание! Переводы принимаются только с карты Monobank. Иначе заказ будет аннулирован.\n\nВладислав Г.\n4441 1110 3909 5051\n\nПосле оплаты нажмите кнопку ниже.",
            "ua": "Оплата карткою. Увага! Перекази приймаються тільки з картки Monobank. Інакше замовлення буде анульовано.\n\nВладислав Г.\n4441 1110 3909 5051\n\nПісля оплати натисніть кнопку нижче."
        },
        "pay_crypto_info": {
            "ru": "Оплатите криптовалютой на адрес ниже.\n\nTON Wallet:\nUQDjclQadIIq-DUoTNY53oHfcp9WVi5mRVnUVxVUnQ-vznEc\n\nПосле оплаты нажмите кнопку ниже.",
            "ua": "Оплатіть криптовалютою за адресою нижче.\n\nTON Wallet:\nUQDjclQadIIq-DUoTNY53oHfcp9WVi5mRVнUVxVUnQ-vznEc\n\nПісля оплати натисніть кнопку нижче."
        },
        "pay_done": {"ru": "Оплачено", "ua": "Оплачено"},
        "pay_done_wait": {"ru": "Ваш платеж ожидает подтверждения администратора.", "ua": "Ваш платіж очікує підтвердження адміністратора."},
        "pay_confirmed": {"ru": "Оплата подтверждена! Скоро с вами свяжутся.", "ua": "Оплата підтверджена! Незабаром з вами зв'яжуться."},
        "order_status_paid": {"ru": "Оплачен ✅", "ua": "Оплачено ✅"},
        "order_status_completed": {"ru": "Завершён ✅", "ua": "Завершено ✅"},
        "confirm_received": {"ru": "Подтвердить получение", "ua": "Підтвердити отримання"},
        "referral": {"ru": "Реферальная система", "ua": "Реферальна система"},
        "referral_link_caption": {"ru": "Ваша реферальная ссылка:", "ua": "Ваше реферальне посилання:"},
        "referral_notify": {
            "ru": "Ваши рефералы совершили покупки на сумму {sum} грн. Вы получаете подарок - любую жидкость из ассортимента или любые два картриджа на выбор.", "ua": "Ваші реферали здійснили покупки на суму {sum} грн. Ви отримуєте подарунок - будь-яку рідину з асортименту або будь-які два картриджі на вибір.",
        },
        "reviews": {"ru": "Отзывы", "ua": "Відгуки"},
        "review_prompt": {"ru": "Напишите ваш отзыв:", "ua": "Напишіть ваш відгук:"},
        "review_added": {"ru": "Спасибо за отзыв! Он будет рассмотрен администратором.", "ua": "Дякуємо за відгук! Він буде розглянутий адміністратором."},
        "admin_panel": {"ru": "Сервем-панель", "ua": "Сервем-панель"},
        "broadcast_prompt": {"ru": "Отправьте текст рассылки одним сообщением. Будет отправлено всем пользователям.", "ua": "Надішліть текст розсилки одним повідомленням. Буде надіслано всім користувачам."},
        "broadcast_ok": {"ru": "Рассылка запущена. Сообщения отправляются.", "ua": "Розсилка запущена. Повідомлення надсилаються."},
        "old_button": {"ru": "Кнопка устарела. Откройте актуальное меню.", "ua": "Кнопка застаріла. Відкрийте актуальне меню."},
    }
    return texts.get(key, {}).get(lang, texts.get(key, {}).get("ru", key))

def currency(amount: int) -> str:
    return f"{amount} грн"

# ===============================
# --------- BOT INIT ------------
# ===============================

bot = telebot.TeleBot(TOKEN, parse_mode="HTML")

# Global ephemeral states
WAITING_REVIEW: Dict[int, bool] = {}     # uid -> True if waiting for review text
WAITING_BROADCAST: Dict[int, bool] = {}  # admin uid -> True if waiting broadcast text

# ===============================
# -------- MARKUPS --------------
# ===============================

def main_menu_markup(uid: int) -> types.ReplyKeyboardMarkup:
    lang = get_lang(uid)
    role = get_role(uid)
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True)
    kb.row("📚 " + t("catalog", lang), "🧺 " + t("cart", lang))
    kb.row("📦 " + t("orders", lang), "👥 " + t("referral", lang))
    kb.row("⭐ " + t("reviews", lang))
    if int(uid) == ADMIN_CHAT_ID or role == "admin":
        kb.row("🛠 " + t("admin_panel", lang), "📢 Рассылка")
    return kb

def catalog_menu(lang: str, vt: int) -> types.InlineKeyboardMarkup:
    mk = types.InlineKeyboardMarkup(row_width=1)
    mk.add(
        types.InlineKeyboardButton(t("cartridges", lang), callback_data=f"v{vt}:cat_cartridges"),
        types.InlineKeyboardButton(t("pods", lang), callback_data=f"v{vt}:cat_pods"),
        types.InlineKeyboardButton(t("liquids", lang), callback_data=f"v{vt}:cat_liquids"),
        types.InlineKeyboardButton(t("back", lang), callback_data=f"v{vt}:back_main")
    )
    return mk

def cartridges_menu(lang: str, vt: int) -> types.InlineKeyboardMarkup:
    mk = types.InlineKeyboardMarkup(row_width=1)
    mk.add(
        types.InlineKeyboardButton("Voopoo", callback_data=f"v{vt}:cat_voopoo"),
        types.InlineKeyboardButton("Vaporesso", callback_data=f"v{vt}:cat_vaporesso"),
        types.InlineKeyboardButton("Elf Bar ELFX", callback_data=f"v{vt}:cat_elfx"),
        types.InlineKeyboardButton(t("back", lang), callback_data=f"v{vt}:cat_back")
    )
    return mk

def products_menu(category: str, lang: str, vt: int) -> types.InlineKeyboardMarkup:
    mk = types.InlineKeyboardMarkup(row_width=1)
    for key, p in PRODUCTS.items():
        if p["category"] == category:
            name = p["name_ru"] if lang == "ru" else p["name_ua"]
            mk.add(types.InlineKeyboardButton(f"{name} - {p['price']} грн", callback_data=f"v{vt}:add_{key}"))
    mk.add(types.InlineKeyboardButton(t("back", lang), callback_data=f"v{vt}:cat_cartridges"))
    return mk

def pods_menu(lang: str, vt: int) -> types.InlineKeyboardMarkup:
    mk = types.InlineKeyboardMarkup(row_width=1)
    for key, p in PODS.items():
        name = p["name_ru"] if lang == "ru" else p["name_ua"]
        mk.add(types.InlineKeyboardButton(f"{name} - {p['price']} грн", callback_data=f"v{vt}:add_{key}"))
    mk.add(types.InlineKeyboardButton(t("back", lang), callback_data=f"v{vt}:cat_back"))
    return mk

def liquids_root(lang: str, vt: int) -> types.InlineKeyboardMarkup:
    mk = types.InlineKeyboardMarkup(row_width=1)
    mk.add(
        types.InlineKeyboardButton("Chaser", callback_data=f"v{vt}:liq_chaser"),
        types.InlineKeyboardButton("Elfliq", callback_data=f"v{vt}:liq_elfliq"),
        types.InlineKeyboardButton("Elix", callback_data=f"v{vt}:liq_elix"),
        types.InlineKeyboardButton(t("back", lang), callback_data=f"v{vt}:cat_back"),
    )
    return mk

def liquids_brand_menu(brand: str, lang: str, vt: int) -> types.InlineKeyboardMarkup:
    mk = types.InlineKeyboardMarkup(row_width=1)
    if brand == "chaser":
        mk.add(types.InlineKeyboardButton("Chaser 30ml", callback_data=f"v{vt}:liq_chaser_30"),
               types.InlineKeyboardButton("Chaser 10ml", callback_data=f"v{vt}:liq_chaser_10"))
    elif brand == "elfliq":
        mk.add(types.InlineKeyboardButton("Elfliq 30ml", callback_data=f"v{vt}:liq_elfliq_30"),
               types.InlineKeyboardButton("Elfliq 10ml", callback_data=f"v{vt}:liq_elfliq_10"))
    elif brand == "elix":
        mk.add(types.InlineKeyboardButton("Elix 30ml", callback_data=f"v{vt}:liq_elix_30"),
               types.InlineKeyboardButton("Elix 10ml", callback_data=f"v{vt}:liq_elix_10"))
    mk.add(types.InlineKeyboardButton(t("back", lang), callback_data=f"v{vt}:cat_liquids"))
    return mk

def liquids_products(category: str, lang: str, vt: int) -> types.InlineKeyboardMarkup:
    mk = types.InlineKeyboardMarkup(row_width=1)
    for key, p in LIQUIDS.items():
        if p["category"] == category:
            name = p["name_ru"] if lang == "ru" else p["name_ua"]
            mk.add(types.InlineKeyboardButton(f"{name} - {p['price']} грн", callback_data=f"v{vt}:add_{key}"))
    mk.add(types.InlineKeyboardButton(t("back", lang), callback_data=f"v{vt}:cat_liquids"))
    return mk

# ===============================
# --------- HELPERS -------------
# ===============================

def product_by_key(key: str):
    return LIQUIDS.get(key) or PRODUCTS.get(key) or PODS.get(key)

def format_items(items: List[str], lang: str) -> str:
    lines = []
    for key in items:
        p = product_by_key(key)
        if not p: 
            continue
        name = p["name_ru"] if lang == "ru" else p["name_ua"]
        lines.append(f"• {name} — {currency(p['price'])}")
    return "\n".join(lines) if lines else "—"

def cart_total(uid: int) -> int:
    total = 0
    for key in get_cart(uid):
        p = product_by_key(key)
        if p:
            total += int(p["price"])
    return total

def send_admin(text: str, reply_markup: Optional[types.InlineKeyboardMarkup]=None):
    try:
        bot.send_message(ADMIN_CHAT_ID, text, reply_markup=reply_markup)
    except Exception as e:
        log.error(f"send_admin error: {e}")

def ref_link(bot_username: str, uid: int) -> str:
    return f"https://t.me/{bot_username}?start={uid}"

# ===============================
# --------- UI FLOWS ------------
# ===============================

@bot.message_handler(commands=["start"])
def cmd_start(message: types.Message):
    uid = message.from_user.id
    ensure_user(uid)

    # referral
    if message.text and " " in message.text:
        parts = message.text.split(maxsplit=1)
        if len(parts) > 1 and parts[1].isdigit():
            add_referral(parent_id=int(parts[1]), child_id=uid)

    lang = get_lang(uid)
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    kb.row("Русский 🇷🇺", "Українська 🇺🇦")
    bot.send_message(uid, t("language_select", lang), reply_markup=kb)

@bot.message_handler(func=lambda m: m.text in ["Русский 🇷🇺", "Українська 🇺🇦"])
def on_language(message: types.Message):
    uid = message.from_user.id
    set_lang(uid, "ru" if message.text.startswith("Рус") else "ua")
    bot.send_message(uid, t("main_menu", get_lang(uid)), reply_markup=main_menu_markup(uid))

@bot.message_handler(commands=["admin"])
def cmd_admin(message: types.Message):
    uid = message.from_user.id
    if uid != ADMIN_CHAT_ID:
        bot.reply_to(message, "Нет доступа.")
        return
    open_admin_panel(uid, message)

def open_admin_panel(uid: int, message: Optional[types.Message]=None):
    lang = get_lang(uid)
    vt = get_view_token(uid)
    mk = types.InlineKeyboardMarkup(row_width=2)
    mk.add(
        types.InlineKeyboardButton("📦 Заказы", callback_data=f"v{vt}:admin_orders"),
    )
    mk.add(
        types.InlineKeyboardButton("👥 Рефералы", callback_data=f"v{vt}:admin_referrals"),
        types.InlineKeyboardButton("📢 Рассылка", callback_data=f"v{vt}:admin_broadcast"),
    )
    mk.add(types.InlineKeyboardButton(t("back", lang), callback_data=f"v{vt}:back_main"))
    if message:
        bot.send_message(uid, "🛠 Сервем-панель", reply_markup=mk)
    else:
        bot.send_message(uid, "🛠 Сервем-панель", reply_markup=mk)

@bot.message_handler(func=lambda m: True)
def main_router(message: types.Message):
    uid = message.from_user.id
    text = message.text or ""
    lang = get_lang(uid)

    # Admin-only explicit buttons
    if (text.startswith("🛠") or text.lower().strip()=="/admin") and uid == ADMIN_CHAT_ID:
        open_admin_panel(uid, message)
        return

    if text.startswith("📢"):
        if uid != ADMIN_CHAT_ID:
            bot.reply_to(message, "Нет доступа.")
            return
        WAITING_BROADCAST[uid] = True
        bot.reply_to(message, t("broadcast_prompt", lang))
        return

    if WAITING_BROADCAST.get(uid):
        WAITING_BROADCAST.pop(uid, None)
        bot.reply_to(message, t("broadcast_ok", lang))
        # send to all users
        for sid in list(USERS.keys()):
            try:
                bot.send_message(int(sid), message.text)
                time.sleep(0.03)
            except Exception:
                pass
        return

    if text.startswith("📚"):
        vt = get_view_token(uid)
        bot.send_message(uid, t("catalog", lang), reply_markup=catalog_menu(lang, vt))
        return

    if text.startswith("🧺"):
        show_cart(uid)
        return

    if text.startswith("📦"):
        show_orders(uid)
        return

    if text.startswith("👥"):
        show_referrals(uid)
        return

    if text.startswith("⭐"):
        open_reviews(uid)
        return

    # fallback
    bot.send_message(uid, t("main_menu", lang), reply_markup=main_menu_markup(uid))

def show_cart(uid: int):
    lang = get_lang(uid)
    items = get_cart(uid)
    if not items:
        bot.send_message(uid, t("cart_empty", lang), reply_markup=main_menu_markup(uid))
        return
    vt = get_view_token(uid)
    total = cart_total(uid)
    text = f"🧺 {t('cart', lang)}:\n\n{format_items(items, lang)}\n\nИтого: {currency(total)}"
    mk = types.InlineKeyboardMarkup()
    mk.add(types.InlineKeyboardButton(t("checkout", lang), callback_data=f"v{vt}:checkout"))
    mk.add(types.InlineKeyboardButton("Очистить корзину", callback_data=f"v{vt}:clear_cart"))
    mk.add(types.InlineKeyboardButton(t("back", lang), callback_data=f"v{vt}:back_main"))
    bot.send_message(uid, text, reply_markup=mk)

def show_orders(uid: int):
    lang = get_lang(uid)
    my = [o for o in ORDERS.values() if o["user_id"] == uid]
    if not my:
        bot.send_message(uid, t("orders_empty", lang))
        return
    for o in sorted(my, key=lambda x: x["id"], reverse=True)[:20]:
        vt = get_view_token(uid)
        items_text = format_items(o["items"], lang)
        status_text = t("order_status_paid", lang) if o.get("paid") else o.get("status", "")
        msg = f"Заказ #{o['id']}:\n{items_text}\nСумма: {currency(o['total'])}\nСтатус: {status_text}\nМетод оплаты: {o.get('payment_method') or '—'}"
        mk = types.InlineKeyboardMarkup()
        if o.get("paid") and not o.get("confirmed"):
            mk.add(types.InlineKeyboardButton(t("confirm_received", lang), callback_data=f"v{vt}:confirm_{o['id']}"))
        bot.send_message(uid, msg, reply_markup=mk)

def show_referrals(uid: int):
    lang = get_lang(uid)
    refs = REF["map"].get(str(uid), [])
    spent = int(REF["spending"].get(str(uid), 0))
    try:
        me = bot.get_me()
        link = ref_link(me.username, uid)
    except Exception:
        link = f"https://t.me/your_bot?start={uid}"
    bot.send_message(uid, f"Вы пригласили: {len(refs)} человек(а).\nПотрачено вашими рефералами: {currency(spent)}\n{t('referral_link_caption', lang)}\n{link}")

# ===============================
# --------- CALLBACKS -----------
# ===============================

@bot.callback_query_handler(func=lambda c: True)
def on_cb(call: types.CallbackQuery):
    try:
        uid = call.from_user.id
        lang = get_lang(uid)
        data = call.data or ""

        # Extract view token
        if not data.startswith("v") or ":" not in data:
            bot.answer_callback_query(call.id, t("old_button", lang), show_alert=True)
            return
        token_str, action = data.split(":", 1)
        try:
            token = int(token_str[1:])
        except ValueError:
            bot.answer_callback_query(call.id, t("old_button", lang), show_alert=True)
            return

        if get_role(uid) != "admin" and not check_view_token(uid, token):
            bot.answer_callback_query(call.id, "Кнопка застрягла. Відкрийте актуальне меню.")
            return

        # --- NAVIGATION ---
        if action == "back_main":
            bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
            bot.send_message(uid, t("main_menu", lang), reply_markup=main_menu_markup(uid))
            bot.answer_callback_query(call.id); return

        # Catalog
        if action == "cat_cartridges":
            vt = get_view_token(uid)
            bot.edit_message_text(t("cartridges", lang), uid, call.message.message_id, reply_markup=cartridges_menu(lang, vt))
            bot.answer_callback_query(call.id); return
        if action == "cat_pods":
            vt = get_view_token(uid)
            bot.edit_message_text(t("pods", lang), uid, call.message.message_id, reply_markup=pods_menu(lang, vt))
            bot.answer_callback_query(call.id); return
        if action == "cat_liquids":
            vt = get_view_token(uid)
            bot.edit_message_text(t("liquids", lang), uid, call.message.message_id, reply_markup=liquids_root(lang, vt))
            bot.answer_callback_query(call.id); return
        if action == "cat_back":
            vt = get_view_token(uid)
            bot.edit_message_text(t("catalog", lang), uid, call.message.message_id, reply_markup=catalog_menu(lang, vt))
            bot.answer_callback_query(call.id); return

        # Cartridges brands
        if action == "cat_voopoo":
            vt = get_view_token(uid)
            bot.edit_message_text("Voopoo", uid, call.message.message_id, reply_markup=products_menu("voopoo", lang, vt))
            bot.answer_callback_query(call.id); return
        if action == "cat_vaporesso":
            vt = get_view_token(uid)
            bot.edit_message_text("Vaporesso", uid, call.message.message_id, reply_markup=products_menu("vaporesso", lang, vt))
            bot.answer_callback_query(call.id); return
        if action == "cat_elfx":
            vt = get_view_token(uid)
            bot.edit_message_text("Elf Bar ELFX", uid, call.message.message_id, reply_markup=products_menu("elfx", lang, vt))
            bot.answer_callback_query(call.id); return

        # Liquids brands
        if action == "liq_chaser":
            vt = get_view_token(uid)
            bot.edit_message_text("Chaser", uid, call.message.message_id, reply_markup=liquids_brand_menu("chaser", lang, vt))
            bot.answer_callback_query(call.id); return
        if action == "liq_elfliq":
            vt = get_view_token(uid)
            bot.edit_message_text("Elfliq", uid, call.message.message_id, reply_markup=liquids_brand_menu("elfliq", lang, vt))
            bot.answer_callback_query(call.id); return
        if action == "liq_elix":
            vt = get_view_token(uid)
            bot.edit_message_text("Elix", uid, call.message.message_id, reply_markup=liquids_brand_menu("elix", lang, vt))
            bot.answer_callback_query(call.id); return

        # Liquids sizes
        if action.startswith("liq_"):
            parts = action.split("_")
            if len(parts) == 3:
                _, brand, size = parts
                category = f"{brand}_{size}"
                vt = get_view_token(uid)
                bot.edit_message_text(f"{brand.capitalize()} {size.replace('_',' ')}", uid, call.message.message_id, reply_markup=liquids_products(category, lang, vt))
                bot.answer_callback_query(call.id); return

        # Add item
        if action.startswith("add_"):
            key = action[4:]
            p = product_by_key(key)
            if not p:
                bot.answer_callback_query(call.id, "❌ Товар не найден", show_alert=True); return
            add_to_cart(uid, key)
            name = p["name_ru"] if lang == "ru" else p["name_ua"]
            bot.answer_callback_query(call.id, f"✅ {name} добавлен в корзину ({p['price']} грн)"); return

        # Cart actions
        if action == "clear_cart":
            clear_cart(uid)
            bot.edit_message_text(t("cart_cleared", lang), uid, call.message.message_id)
            bot.answer_callback_query(call.id); return

        if action == "checkout":
            cart = get_cart(uid)
            if not cart:
                bot.answer_callback_query(call.id, t("cart_empty", lang), show_alert=True); return
            oid = new_order_id()
            total = cart_total(uid)
            ORDERS[str(oid)] = {
                "id": oid,
                "user_id": uid,
                "items": cart.copy(),
                "total": total,
                "status": "created",
                "payment_method": None,
                "paid": False,
                "confirmed": False,
                "created": int(time.time())
            }
            _save(F_ORDERS, ORDERS)
            clear_cart(uid)
            vt2 = get_view_token(uid)
            mk = types.InlineKeyboardMarkup(row_width=1)
            mk.add(types.InlineKeyboardButton(t("pay_cod", lang), callback_data=f"v{vt2}:pay_cod_{oid}"))
            mk.add(types.InlineKeyboardButton(t("pay_card", lang), callback_data=f"v{vt2}:pay_card_{oid}"))
            mk.add(types.InlineKeyboardButton(t("pay_crypto", lang), callback_data=f"v{vt2}:pay_crypto_{oid}"))
            mk.add(types.InlineKeyboardButton(t("back", lang), callback_data=f"v{vt2}:back_main"))
            bot.edit_message_text(t("order_created", lang).format(order_id=oid), uid, call.message.message_id, reply_markup=mk)
            bot.answer_callback_query(call.id); return

        # Payments
        if action.startswith("pay_cod_"):
            oid = int(action.split("_")[-1])
            o = ORDERS.get(str(oid))
            if not o or o["user_id"] != uid:
                bot.answer_callback_query(call.id, "Заказ не найден", show_alert=True); return
            o["payment_method"] = "cod"; o["paid"] = False; o["status"] = "awaiting_delivery"
            _save(F_ORDERS, ORDERS)
            bot.edit_message_text("Вы выбрали оплату при получении.", uid, call.message.message_id)
            it = format_items(o["items"], lang)
            send_admin(f"🆕 Заказ #{oid} от @{call.from_user.username or call.from_user.id}\nМетод: Наложенный платёж\nСумма: {currency(o['total'])}\nСостав:\n{it}")
            bot.answer_callback_query(call.id); return

        if action.startswith("pay_card_"):
            oid = int(action.split("_")[-1])
            o = ORDERS.get(str(oid))
            if not o or o["user_id"] != uid:
                bot.answer_callback_query(call.id, "Заказ не найден", show_alert=True); return
            o["payment_method"] = "card"; o["paid"] = False; o["status"] = "waiting_confirmation"
            _save(F_ORDERS, ORDERS)
            vt2 = get_view_token(uid)
            mk = types.InlineKeyboardMarkup()
            mk.add(types.InlineKeyboardButton(t("pay_done", lang), callback_data=f"v{vt2}:paid_confirm_{oid}"))
            bot.edit_message_text(t("pay_prepay_info", lang), uid, call.message.message_id, reply_markup=mk)
            bot.answer_callback_query(call.id); return

        if action.startswith("pay_crypto_"):
            oid = int(action.split("_")[-1])
            o = ORDERS.get(str(oid))
            if not o or o["user_id"] != uid:
                bot.answer_callback_query(call.id, "Заказ не найден", show_alert=True); return
            o["payment_method"] = "crypto"; o["paid"] = False; o["status"] = "waiting_confirmation"
            _save(F_ORDERS, ORDERS)
            vt2 = get_view_token(uid)
            mk = types.InlineKeyboardMarkup()
            mk.add(types.InlineKeyboardButton(t("pay_done", lang), callback_data=f"v{vt2}:paid_confirm_{oid}"))
            bot.edit_message_text(t("pay_crypto_info", lang), uid, call.message.message_id, reply_markup=mk)
            bot.answer_callback_query(call.id); return

        if action.startswith("paid_confirm_"):
            oid = int(action.split("_")[-1])
            o = ORDERS.get(str(oid))
            if not o or o["user_id"] != uid:
                bot.answer_callback_query(call.id, "Заказ не найден", show_alert=True); return
            o["paid"] = True
            o["status"] = "waiting_admin_confirmation"
            _save(F_ORDERS, ORDERS)
            items_text = format_items(o["items"], lang)
            mk = types.InlineKeyboardMarkup()
            mk.add(types.InlineKeyboardButton("Подтвердить оплату", callback_data=f"v{get_view_token(ADMIN_CHAT_ID)}:admin_confirm_{oid}"))
            send_admin(f"💳 Пользователь @{call.from_user.username or call.from_user.id} сообщил об оплате заказа #{oid}.\nМетод: {o['payment_method']}\nСумма: {currency(o['total'])}\nСостав:\n{items_text}", reply_markup=mk)
            bot.edit_message_text(t("pay_done_wait", lang), uid, call.message.message_id)
            bot.answer_callback_query(call.id); return

        if action.startswith("confirm_"):
            oid = int(action.split("_")[-1])
            o = ORDERS.get(str(oid))
            if not o or o["user_id"] != uid:
                bot.answer_callback_query(call.id, "Ошибка", show_alert=True); return
            o["confirmed"] = True; o["status"] = "completed"
            _save(F_ORDERS, ORDERS)
            bot.edit_message_text(f"Заказ #{oid} {t('order_status_completed', lang)}", uid, call.message.message_id)
            bot.answer_callback_query(call.id); return

        # Reviews
        if action == "review_add":
            WAITING_REVIEW[uid] = True
            bot.send_message(uid, t("review_prompt", lang))
            bot.answer_callback_query(call.id); return
        if action == "review_show":
            approved = [r for r in REVIEWS if r.get("approved")]
            if not approved:
                bot.answer_callback_query(call.id, "Пока нет отзывов.", show_alert=True); return
            text = "\n\n".join([f"@{bot.get_chat(r['user_id']).username or r['user_id']}: {r['text']}" for r in approved[-10:]])
            bot.edit_message_text(text, uid, call.message.message_id)
            bot.answer_callback_query(call.id); return

        # Admin actions
        if action == "admin_orders" and uid == ADMIN_CHAT_ID:
            pending = [
                o for o in sorted(ORDERS.values(), key=lambda x: x["id"], reverse=True)
                if o["status"] not in ["completed", "canceled"]
            ][:30]
            for o in pending:
                vt2 = get_view_token(uid)
                items_text = format_items(o["items"], lang)
                mk = types.InlineKeyboardMarkup(row_width=3)
                mk.add(types.InlineKeyboardButton("✅ Подтвердить оплату", callback_data=f"v{vt2}:admin_confirm_{o['id']}"))
                mk.add(types.InlineKeyboardButton("📦 Завершить", callback_data=f"v{vt2}:admin_complete_{o['id']}"))
                mk.add(types.InlineKeyboardButton("🗑 Отменить", callback_data=f"v{vt2}:admin_cancel_{o['id']}"))
                bot.send_message(uid, f"#{o['id']} | {currency(o['total'])} | {o['status']} | {o.get('payment_method') or '—'}\n{items_text}", reply_markup=mk)
            bot.answer_callback_query(call.id); return

        if action == "admin_reviews" and uid == ADMIN_CHAT_ID:
            for idx, r in enumerate(REVIEWS):
                if not r.get("approved"):
                    vt2 = get_view_token(uid)
                    mk = types.InlineKeyboardMarkup()
                    mk.add(types.InlineKeyboardButton("✅ Разрешить", callback_data=f"v{vt2}:admin_rev_ok_{idx}"))
                    mk.add(types.InlineKeyboardButton("❌ Запретить", callback_data=f"v{vt2}:admin_rev_del_{idx}"))
                    bot.send_message(uid, f"От @{bot.get_chat(r['user_id']).username or r['user_id']}:\n{r['text']}", reply_markup=mk)
            bot.answer_callback_query(call.id); return

        if action == "admin_referrals" and uid == ADMIN_CHAT_ID:
            lines = []
            for ref, childs in REF["map"].items():
                spend = int(REF["spending"].get(ref, 0))
                lines.append(f"👤 {ref}: пригласил {len(childs)}, сумма {currency(spend)}")
            bot.send_message(uid, "\n".join(lines) if lines else "Нет данных.")
            bot.answer_callback_query(call.id); return

        if action == "admin_broadcast" and uid == ADMIN_CHAT_ID:
            WAITING_BROADCAST[uid] = True
            bot.send_message(uid, t("broadcast_prompt", lang))
            bot.answer_callback_query(call.id); return

        if action.startswith("admin_confirm_") and uid == ADMIN_CHAT_ID:
            oid = int(action.split("_")[-1])
            o = ORDERS.get(str(oid))
            if not o:
                bot.answer_callback_query(call.id, "Заказ не найден", show_alert=True); return
            o["paid"] = True; o["status"] = "paid"
            _save(F_ORDERS, ORDERS)
            buyer = o["user_id"]
            bot.send_message(buyer, t("pay_confirmed", get_lang(buyer)))
            bot.answer_callback_query(call.id, f"Подтвержден #{oid}")
            # referral
            # find referrer
            referrer = None
            for r, lst in REF["map"].items():
                if str(buyer) in lst:
                    referrer = int(r); break
            if referrer:
                add_spending(referrer, o["total"])
                spent = int(REF["spending"].get(str(referrer), 0))

            # Проверяем, что достигнут порог и награда ещё не выдавалась
                if spent >= REF_REWARD_THRESHOLD:
                    if not REF.get("rewards", {}).get(str(referrer)):
                        bot.send_message(
                            referrer,
                            t("referral_notify", get_lang(referrer)).format(sum=spent)
            )
            # Помечаем, что награда выдана
            REF.setdefault("rewards", {})[str(referrer)] = True
            _save(F_REFERRALS, REF)

            return

        if action.startswith("admin_complete_") and uid == ADMIN_CHAT_ID:
            oid = int(action.split("_")[-1])
            o = ORDERS.get(str(oid))
            if not o:
                bot.answer_callback_query(call.id, "Заказ не найден", show_alert=True); return
            o["status"] = "completed"
            _save(F_ORDERS, ORDERS)
            bot.answer_callback_query(call.id, f"Завершен #{oid}"); return

        if action.startswith("admin_cancel_") and uid == ADMIN_CHAT_ID:
            oid = int(action.split("_")[-1])
            o = ORDERS.get(str(oid))
            if not o:
                bot.answer_callback_query(call.id, "Заказ не найден", show_alert=True); return
            o["status"] = "canceled"
            _save(F_ORDERS, ORDERS)
            bot.answer_callback_query(call.id, f"Отменен #{oid}"); return

        if action.startswith("admin_rev_ok_") and uid == ADMIN_CHAT_ID:
            idx = int(action.split("_")[-1])
            if approve_review(idx):
                bot.answer_callback_query(call.id, "Одобрено")
            else:
                bot.answer_callback_query(call.id, "Ошибка", show_alert=True)
            return

        if action.startswith("admin_rev_del_") and uid == ADMIN_CHAT_ID:
            idx = int(action.split("_")[-1])
            if delete_review(idx):
                bot.answer_callback_query(call.id, "Удалено")
            else:
                bot.answer_callback_query(call.id, "Ошибка", show_alert=True)
            return

    except Exception as e:
        log.exception("callback error")
        try:
            bot.answer_callback_query(call.id, "Ошибка")
        except Exception:
            pass

@bot.message_handler(func=lambda m: WAITING_REVIEW.get(m.from_user.id) is True, content_types=["text"])
def on_review_text(message: types.Message):
    uid = message.from_user.id
    lang = get_lang(uid)
    text = message.text.strip()
    if len(text) < 3:
        bot.reply_to(message, "Отзыв слишком короткий, попробуйте еще раз.")
        return
    WAITING_REVIEW.pop(uid, None)
    add_review(uid, text)
    bot.reply_to(message, t("review_added", lang))
    # send to admin
    idx = len(REVIEWS) - 1
    mk = types.InlineKeyboardMarkup()
    vt = get_view_token(ADMIN_CHAT_ID)
    mk.add(types.InlineKeyboardButton("✅ Разрешить", callback_data=f"v{vt}:admin_rev_ok_{idx}"))
    mk.add(types.InlineKeyboardButton("❌ Запретить", callback_data=f"v{vt}:admin_rev_del_{idx}"))
    send_admin(f"Новый отзыв от @{message.from_user.username or uid}:\n\n{text}", reply_markup=mk)

# ===============================
# --------- POLLING -------------
# ===============================

def main():
    log.info("Bot starting...")
    bot.infinity_polling(skip_pending=True, timeout=30, long_polling_timeout=30)

if __name__ == "__main__":
    main()
